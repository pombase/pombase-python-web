<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protein features for {{gene_uniquename}} </title>
    <link href="https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/dist/tippy.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/themes/light-border.css" rel="stylesheet">
  </head>
  <body>
    <div id="pfv" style="margin-top:20px" ></div>

  <style>
  .rcsbFvRowTitleText {
    text-transform: uppercase;
  }
  .rcsbDecorator_circle {
    display: none;
  }
  .no-features {
    font-size: 120%;
    padding: 1em;
  }
  </style>

    <script src="https://cdn.jsdelivr.net/npm/@rcsb/rcsb-saguaro/build/rcsb-saguaro.js" type="text/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/dist/tippy.umd.min.js"></script>

  <script language="javascript" type="text/javascript">
function noData() {
  document.getElementById('pfv').innerHTML = '<div class="no-features">No features available for {{gene_uniquename}}</div>';
}

window.onload = (event) => {

fetch("/api/v1/dataset/latest/protein_features/{{full_or_widget}}/{{gene_uniquename}}")
  .then((response) => {
    return response.json();
  })
  .then((data) => {
    if (!data.tracks) {
      noData();
      return;
    }

    let hasFeatures = false;

    let rowConfigData = [
      {
        trackId: "sequenceTrack",
        trackHeight: 20,
        trackColor: "#F9F9F9",
        displayType: "sequence",
        nonEmptyDisplay: true,
        rowTitle: "Sequence",
        trackData: [
          {
            begin: 1,
            value: data.sequence
          }
        ]
      }
    ];

    const typeConfig = {
      'TM domains': {
        colour: '#44f',
        allowGaps: true
      },
      'Disordered regions': {
        colour: '#292',
        allowGaps: true
      },
      'Low complexity': {
        colour: '#0aa',
        allowGaps: true
      },
      'Coiled coils': {
        colour: '#a5a',
        allowGaps: true
      },
      'Mutants': {
        colour: '#f00',
        allowGaps: true,
      },
      'Partial deletions': {
        colour: '#73a',
        allowGaps: true,
        invertGaps: true
      },
      'Modifications': {
        colour: '#00f',
        allowGaps: false
      },
      'Pfam families': {
        colour: '#aa0',
        allowGaps: true
      },
    }

    data.tracks.map(track => {
      if (track.features.length > 0) {
        hasFeatures = true;

        const trackData = [];

        const makeTrackData = (feature) => {
          const firstPos = feature.positions[0];
          const lastPos = feature.positions[feature.positions.length - 1];
          const newFeature = {
            id: feature.id + firstPos + '..' + lastPos,
            displayName: feature.display_name,
            begin: firstPos[1],
            end: lastPos[2],
          };

          if (feature.positions.length > 1) {
            let gaps = [];
            for (let i = 0; i < feature.positions.length - 1; i++) {
              const current = feature.positions[i];
              const currentEnd = current[2];
              const next = feature.positions[i+1];
              const nextStart = next[1];
              if (currentEnd < nextStart - 1) {
                gaps.push({
                  begin: currentEnd,
                  end: nextStart,
                });
              }
            }
            newFeature.gaps = gaps;
          }

          return newFeature;
        };
        const makeTrackDataInvertGaps = (feature) => {
          const sequence = data.sequence;

          const firstPos = 1;
          const lastPos = sequence.length;
          const newFeature = {
            id: feature.id + firstPos + '..' + lastPos,
            displayName: feature.display_name,
            begin: firstPos,
            end: lastPos,
          };

          let gaps = [];
          for (let i = 0; i < feature.positions.length; i++) {
            const current = feature.positions[i];
            const begin = current[1];
            const end = current[2] + 1;

            gaps.push({
              begin,
              end,
            });

            newFeature.gaps = gaps;
          }

          return newFeature;
        };

        for (const feature of track.features) {
          const allowGaps = typeConfig[track.name]?.allowGaps || false;
          if (allowGaps) {
            const invertGaps = typeConfig[track.name]?.invertGaps || false;
            if (invertGaps) {
              trackData.push(makeTrackDataInvertGaps(feature))
            } else {
              trackData.push(makeTrackData(feature));
            }
          } else {
            for (const position of feature.positions) {
              let featureCopy = { ... feature };
              featureCopy.positions = [position];
              trackData.push(makeTrackData(featureCopy));
            }
          }
        }

        let trackHeight = 20;

        if (track.name == 'Partial deletions') {
          if (trackData.length > 25) {
            trackHeight = 10;
          } else {
            if (trackData.length > 10) {
              trackHeight = 12;
            }
          }
        }

        const conf = {
          trackId: track.name,
          trackHeight,
          trackColor: "#fcfcfc",
          displayType: track.display_type,
          displayColor: typeConfig[track.name]?.colour || '#ba6',
          rowTitle: track.name,
          includeTooltip: true,
          trackData,
        };

        rowConfigData.push(conf);
      }
    });

    if (!hasFeatures) {
      noData();
      return;
    }

    const tooltips = {};

    const boardConfigData = {
      length: data.sequence.length,
      trackWidth: 800,
      includeAxis: true,
      elementEnterCallBack: function(obj, e) {
        if (obj.displayName) {
          const tip = tippy(e.target);
          const props = { theme: 'light-border', maxWidth: '800px', allowHTML: true };
          tip.setProps(props);
          tip.setContent(obj.displayName);
          if (e.offsetX > 600) {
            // avoid ovelapping the right hand controls
            props.placement = 'left';
          }
          tip.show();
          tooltips[obj.id] = tip;
        }
      },
      elementLeaveCallBack: function(obj, e) {
        if (obj.id && tooltips[obj.id]) {
          const tip = tooltips[obj.id];
          tip.destroy();
        }
      },
    };

    const elementId = "pfv";
    const pfv = new RcsbFv.Create({
      boardConfigData,
      rowConfigData,
      elementId
    });
  });
};
    </script>
  </body>
</html>
