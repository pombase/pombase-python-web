<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protein features for {{gene_uniquename}} </title>
    <link href="https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/dist/tippy.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/themes/light-border.css" rel="stylesheet">
  </head>
  <body>
    <div id="pfv" style="margin-top: 1em" ></div>

  <style>
  .rcsbFvRowTitleText {
    text-transform: uppercase;
  }
  .rcsbDecorator_circle {
    display: none;
  }
  .no-features {
    font-size: 120%;
    padding: 1em;
  }
  </style>

    <script src="https://cdn.jsdelivr.net/npm/@rcsb/rcsb-saguaro/build/rcsb-saguaro.js" type="text/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/dist/tippy.umd.min.js"></script>

  <script language="javascript" type="text/javascript">
const geneUniquename = '{{gene_uniquename}}';
const fullOrWidget = '{{full_or_widget}}';

function noData() {
  document.getElementById('pfv').innerHTML = '<div class="no-features">No features available for ' + geneUniquename + '</div>';
}

window.onload = (event) => {

fetch("/api/v1/dataset/latest/protein_features/" + fullOrWidget + "/" + geneUniquename)
  .then((response) => {
    return response.json();
  })
  .then((data) => {
    if (!data.tracks) {
      noData();
      return;
    }

    let hasFeatures = false;

    let rowConfigData = [
      {
        trackId: "sequenceTrack",
        trackHeight: 20,
        trackColor: "#F9F9F9",
        displayType: "sequence",
        nonEmptyDisplay: true,
        rowTitle: "Sequence",
        trackData: [
          {
            begin: 1,
            value: data.sequence
          }
        ]
      }
    ];

    let typeConfig = {
      'Sequence': {
        helpText: 'Zoom in to see residues',
      },
      'TM domains': {
        colour: '#44f',
        allowGaps: true,
        helpText: 'Trans-membrane domains calculated with TMHMM (Krogh et al. 2001)'
      },
      'Disordered regions': {
        colour: '#292',
        allowGaps: true,
        helpText: 'Disordered regions from Pfam version 34.0 (El-Gebali et al. 2019)'
      },
      'Low complexity': {
        colour: '#0aa',
        allowGaps: true,
        helpText: 'Low complexity regions from Pfam version 34.0 (El-Gebali et al. 2019)'
      },
      'Coiled coils': {
        colour: '#a5a',
        allowGaps: true,
        helpText: 'Coiled coils from Pfam version 34.0 (El-Gebali et al. 2019)'
      },
      'Mutant positions': {
        colour: '#f94',
        allowGaps: true,
        helpText: '<div>Positions where there is a mutation in at least one allele</div>' +
          (fullOrWidget == 'widget' ? '<div>Visit the full feature viewer to see allele details</div>' : ''),
      },
      'Mutants': {
        colour: '#f00',
        allowGaps: true,
        helpText: 'Curated alleles',
      },
      'Partial deletions': {
        colour: '#15e',
        allowGaps: true,
        invertGaps: true,
        helpText: 'Curated partial deletions',
      },
      'Modifications': {
        colour: '#00f',
        allowGaps: false,
        helpText: 'Curated modified residues',
      },
      'Pfam families': {
        colour: '#aa0',
        allowGaps: true,
        helpText: 'Pfam domains from InterPro',
      },
    };

    Object.keys(typeConfig).forEach(key => {
      typeConfig[key.toUpperCase()] = typeConfig[key];
    });

    data.tracks.map(track => {
      if (track.features.length > 0) {
        hasFeatures = true;

        const trackData = [];

        const makeTrackData = (feature) => {
          const firstPos = feature.positions[0];
          const lastPos = feature.positions[feature.positions.length - 1];
          const newFeature = {
            id: feature.id + firstPos + '..' + lastPos,
            displayName: feature.display_name,
            begin: firstPos[1],
            end: lastPos[2],
          };

          if (feature.positions.length > 1) {
            let gaps = [];
            for (let i = 0; i < feature.positions.length - 1; i++) {
              const current = feature.positions[i];
              const currentEnd = current[2];
              const next = feature.positions[i+1];
              const nextStart = next[1];
              if (currentEnd < nextStart - 1) {
                gaps.push({
                  begin: currentEnd,
                  end: nextStart,
                });
              }
            }
            newFeature.gaps = gaps;
          }

          return newFeature;
        };
        const makeTrackDataInvertGaps = (feature) => {
          const sequence = data.sequence;

          const firstPos = 1;
          const lastPos = sequence.length;
          const newFeature = {
            id: feature.id + firstPos + '..' + lastPos,
            displayName: feature.display_name,
            begin: firstPos,
            end: lastPos,
          };

          let gaps = [];
          for (let i = 0; i < feature.positions.length; i++) {
            const current = feature.positions[i];
            const begin = current[1] - 1;
            const end = current[2] + 1;

            gaps.push({
              begin,
              end,
            });

            newFeature.gaps = gaps;
          }

          return newFeature;
        };

        for (const feature of track.features) {
          const allowGaps = typeConfig[track.name]?.allowGaps || false;
          if (allowGaps) {
            const invertGaps = typeConfig[track.name]?.invertGaps || false;
            if (invertGaps) {
              trackData.push(makeTrackDataInvertGaps(feature))
            } else {
              trackData.push(makeTrackData(feature));
            }
          } else {
            for (const position of feature.positions) {
              let featureCopy = { ... feature };
              featureCopy.positions = [position];
              trackData.push(makeTrackData(featureCopy));
            }
          }
        }

        let trackHeight = 20;

        if (fullOrWidget == 'widget' && track.name != 'Modifications') {
          trackHeight = 25;
        }

        if (track.name == 'Partial deletions') {
          if (trackData.length > 25) {
            trackHeight = 10;
          } else {
            if (trackData.length > 10) {
              trackHeight = 12;
            }
          }
        }

        const conf = {
          trackId: track.name,
          trackHeight,
          trackColor: "#fcfcfc",
          displayType: track.display_type,
          displayColor: typeConfig[track.name]?.colour || '#ba6',
          rowTitle: track.name,
          includeTooltip: false,
          trackData,
        };

        rowConfigData.push(conf);
      }
    });

    if (!hasFeatures) {
      noData();
      return;
    }

    const tippyProps = {
      theme: 'light-border', maxWidth: '550px', allowHTML: true,
      followCursor: 'initial',
    };

    const tooltips = {};

    const trackWidth = fullOrWidget == 'widget' ? 800 : 1000;

    const boardConfigData = {
      length: data.sequence.length,
      trackWidth,
      includeAxis: true,
      rowTitleWidth: 170,
      hideRowGlow: false,
      highlightHoverElement: false,
      highlightHoverPosition: false,
      elementEnterCallBack: function(obj, e) {
        if (obj.displayName) {
          const tip = tippy(e.target);
          let props = { ... tippyProps };
          tip.setContent(obj.displayName.replaceAll(',', ',&ZeroWidthSpace;'));
          if (e.offsetX > trackWidth - 100 ||
              obj.displayName.length > 60 && e.offsetX > trackWidth - 300) {
            // avoid ovelapping the right hand controls
            props.placement = 'left';
          }
          tip.setProps(props);
          tip.show();
          tooltips[obj.id] = tip;
        }
      },
      elementLeaveCallBack: function(obj, e) {
        if (obj.id && tooltips[obj.id]) {
          const tip = tooltips[obj.id];
          tip.destroy();
        }
      },
    };

    const elementId = "pfv";
    const pfv = new RcsbFv.Create({
      boardConfigData,
      rowConfigData,
      elementId
    });

    pfv.then(() => {
      const titles = document.getElementsByClassName('rcsbFvRowTitleText');

      for (const el of titles) {
        const trackName = el.innerText.trim();
        const conf = typeConfig[trackName];
        if (conf && conf.helpText) {
          const tip = tippy(el, {
            content: conf.helpText,
          });
          let props = { ... tippyProps };
          props.placement = 'right';
          tip.setProps(props);
        }
      }
    });
  });
};
    </script>
  </body>
</html>
